DVim
===
Библиотека DVim реализует парадигму объектно-ориентированного программирования через использование прототипов. Помимо общих механизмов реализации прототипного наследования, реализована полноценная библиотека компонентов, позволяющих управлять множествами, строками и сущностями Vim как программными объектами. Важной особенностью библиотеки является ее модульность и возможность наследования. Благодаря использованию плагинов DVim, можно расширять возможности как самого Vim, так и библиотеки не изменяя исходный код (см. Наследование и Плагины).

Установка и первоначальная настройка
===
Для использования DVim необходимо:
1. Скачать библиотеку;
2. Разместить компоненты библиотеки по адресу `~/.vim/autoload/D/`;
Библиотека готова к использованию.

Все использующие библиотеку компоненты должны подключить файл *startup.vim* библиотеки, после чего, с помощью команд *Use* объявить используемые пакеты библиотеки, которые будут подключены автоматически (см. Использование).

Использование
===
В качестве примера рассмотрим простейший Vim скрипт, использующий компоненты библиотеки DVim (предполагается, что библиотека успешно установлена):
 " Использование пакета Array
 Use D/base/Array
 
 let s:arr = Array.new('integer') " Создание объекта класса Array
 call s:arr.push(1) " Добавление элемента в массив
 echo s:arr.out(0) " 1 - получение элемента массива с индексом 0
В примере используется класс *Array*, представляющий объект типа Массив. Данный класс подключается из библиотеки DVim с помощью команды *Use*. Обратите внимание на адрес пакета *D/base/Array*. Если вы перейдете по адресу `~/.vim/autoload/D/base/`, то увидите файл Array.vim, именно в нем и хранится класс *Array*. Все остальные классы библиотеки храняться и подключаются аналогичным образом. Так, чтобы использовать класс *Conten* используйте команду *Use D/components/Content*.

Классы в DVim
===
Ниже приведен список классов, доступных в DVim:
- base
-- Object - корневой класс библиотеки, реализующий основные методы классов и механизмы наследования
-- Dictionary - объекты данного класса представляют словари
-- Array - объекты данного класса представляют массивы с целочисленными идентификаторами
-- Stack - объекты данного класса представляют массивы с типом доступа Стэк
-- Turn - объекты данного класса представляют массивы с типом доступа Очередь
-- String - объекты данного класса представляют строки
- components
-- Buffer - объекты данного класса представляют загруженные буферы
-- Content - объекты данного класса представляют содержимое загруженных буферов
- dev
-- Test - корневой класс для реализации Unit-tests в системе

Наследование
===
Если вам нужно расширить функциональность библиотеки, не нужно изменять ее исходные коды, достаточно унаследовать поведение у имеющихся в библиотеке классов и уточнить их реализацию.

Рассмотрим пример наследования в DVim:
 Use D/base/Array
 
 let MyArray = Array.expand('MyArray', {'myVar': 'val'}) " Наследование с добавлением свойств
  
 function! MyArray.getMyVar() dict
   return self.get('myVal')
 endfunction
  
 function! MyArray.setMyVar(val) dict
   call self.set('myVal', a:val)
 endfunction
Обратите внимание как выполняется наследование. Сначала вы выбираете подходящий класс от которого будите наследовать реализацию (в данном случае *Array*), этот класс называется прототипом. Затем вы используете метод *expand* и определяете в первом параметре имя нового класса, а во втором передаете список свойств нового класса со значениями по умолчанию. Обратите внимание, что типизация свойств зависит от значений по умолчанию. Так, свойство *myVar* будет принимать только строковые данные. После выполнения, метод *expand* возвращает готовый класс, остается только добавить ему методы, что мы и делаем в примере.

Чтобы получить объект класса, используется метод *new*:
 ... " Реализация MyArray
 let s:ma = MyArray.new('integer') " Создание объекта класса MyArray
Конструктор *new* принимает параметр, так как данное поведение было определено в классе *Dictionary*, являющимся родителем класса *Array*, а значит и *MyArray*.

Если поместить созданный класс в один из каталогов библиотеки DVim, то его можно подключать в будущем с помощью команды *Use*. Так, поместив наш класс в файл `~/.vim/autoload/D/base/MyArray.vim`, его можно подключить с помощью команды `Use D/base/MyArray`.

Плагины
===
Наследование позволяет определять новые классы, но чаще необходимо реализовывать целые пакеты классов - плагины DVim. Рассмотрим пример плагина DVim:
 if !exists('DVim')
   so $HOME/.vim/autoload/D/startup.vim
 elseif type('DVim') != 4
   finish
 endif
 if exists('DVim.plugins.MyPlugin')
   finish
 endif
 DPlugin 'MyPlugin'
 Use D/base/Object
 
 function! DVim.plugins.MyPlugin.sayHello()
   echo 'Hello world!'
 endfunction
 nnoremap <F1> :call DVim.plugins.MyPlugin.sayHello()<CR>

Первое условие позволяет задержать загружку плагина до загрузки библиотеки DVim, так как плагин от нее зависит. Второе условие отменяет загрузку плагина, если в качестве глобальной переменной DVim (определенной в startup.vim скрипте библиотеки) установлен не объект. Третье условие позволяет отменить загрузку данного плагина, если он уже был загружен ранее, или если пользователь сознательно отключает данный плагин добавив запись:
 let DVim.plugins.MyPlugin = 0
в файл startup.vim библиотеки. Команда *DPlugin* создает объект DVim.plugins.MyPlugin, именно этот объект должен включать все свойства и методы плагина (своего рода namespace плагина). В качестве примера плагин использует класс *Object* с помощью команды *Use* (хотя это здесь и не нужно). Так же реализован метод *sayHello* плагина, который запускается по нажатию клавиши *F1*. Теперь файл с плагином достаточно добавить в каталог `~/.vim/plugin/` или `~/.vim/ftplugin/` и его можно использовать.
